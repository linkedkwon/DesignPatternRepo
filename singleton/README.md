# 싱글톤(Singleton)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/DesignPattern-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Singleton-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>


## 1. 싱글톤 패턴이란?
`싱글톤 패턴`은 클래스의 **인스턴스를 애플리케이션 전체 영역에서 단 하나만 생성하여 사용하는 방법**을 의미한다. 보통 환경을  
설정하는 클래스와 커넥션과 상수 등을 저장하는 풀(Pool)과 같이 여러 스레드에서 공용으로 사용될 떄 적합한 디자인 패턴이다.  
일반적으로 Java에서는 클래스 내부에 static, private 생성자, 인스턴스를 반환하는 메소드 등을 사용해 패턴을 적용하며  
프레임워크에서는 싱글톤이 적용된 인스턴스를 관리하는 `컨테이너`를 제공하기도 한다.

<img width="543" alt="singleton" src="https://user-images.githubusercontent.com/78818063/169226065-fbcd1557-383a-4606-9536-4d3fb242216d.png">

위 코드는 싱글톤 패턴이 적용된 클래스의 예시다. 먼저 클래스 필드는 **자신의 인스턴스를 static 키워드로 정의**해 공용으로  
사용할 수 있도록 지정하였으며, **생성자의 접근 제어자는 private**로 선언해 외부로부터의 접근을 막고 있다. 마지막으로 외부에서  
해당 **인스턴스가 필요한 경우 내부 메소드를 통해 반환**받는다. 결론적으로 싱글톤으로 설계된 클래스에서 생성된 객체는 위처럼  
애플리케이션 전역에서 단 하나의 인스턴스 상태를 계속해서 유지한다.

<br>

## 2. 싱글톤의 이점
앞서 살펴본 싱글톤은 인스턴스가 애플리케이션에서 단 하나만 생성됨을 보장되는 `단일 오브젝트`이면서 멀티 스레드  
환경에서 인스턴스의 `공유`가 가능했다. 아래는 싱글톤 패턴을 통해 얻을 수 있는 몇 가지 이점을 설명하고 있다.    

  * ### 재사용과 메모리 낭비 방지 ###
    고정으로 할당된 인스턴스는 애플리케이션 전체 영역에서 **재사용되므로 메모리 낭비 또는 누수 현상을 예방**할 수 있다.  
    
  * ### 인스턴스 공유 ###
    공유되는 클래스를 싱글톤으로 만들어 애플리케이션의 **전체 영역에서 접근**이 가능하다. 
  
  * ### 빠른 사용 속도 보장 ###
    인스턴스를 사용하는 **두 번째 순간부터 로딩 시간이 현저히 줄어들어 높은 속도를 보장**환다.

<br>

## 3. 안티 패턴(Anti Pattern), 싱글톤의 문제점 
싱글톤은 앞서 살펴본 여러 이점과 함께 아래와 같은 문제점 또한 가지고 있어 `안티 패턴`이라고도 불린다.

  * ### OOP(Object Orient Programming)과 거리가 멀다 ###
    전역 상태를 갖는 인스턴스는 어디서나 접근과 수정이 가능한데, **객체의 상태를 이용할 수 없다면** 사실상 객체 지향  
    프로그래밍과는 거리가 멀다. 또한 상속으로 다형성을 부여하기 위해선 기본 생성자가 필요한데, 싱글톤은 private으로  
    외부 접근을 막고 static 필드와 메소드를 사용하므로 **상속과 오버라이딩이 불가능해 객체를 제대로 다룰 수 없다.**
    
  * ### 높은 결합도(Coupling)와 테스트에 부적합 ###
    싱글톤을 사용하는 곳과 해당 인스턴스 사이의 **강한 의존성이으로 애플리케이션 사이 결합도가 높아져 수정, 유지보수  
    단위 테스트 등이 매우 힘들어진다**. 또한 싱글톤의 static 구성 요소들은 해당 인스턴스가 만들어지는 방식을 제한하는데  
    이로 인해 테스트에서 사용되는 `Mock` 객체로 인스턴스를 대체하거나 객체를 주입하기 어렵다.

  * ### 싱글톤이 하나만 만들어지는 것이 보장되지 않는다  ###
    JVM이 분산되어 설치되는 경우 또는 클래스 로더 구성에 따라 실제 서버 환경에서는 싱글톤이 적용된 클래스임에도  
    인스턴스가 여러 개 생성될 우려가 있다.

<br>

## 4. 싱글톤을 언제 사용할까?
싱글톤이 패턴이 적용된 인스턴스는 반드시 **내부 상태를 가지지 않아야 한다**. 전역에서 인스턴스가 공유되므로 멀티 스레드 환경에서  
상태가 변경되는 `Side-Effect`가 발생할 확률이 매우 높다. 실제 서비스에서 `HTTP 메시지`는 `서블릿(Servlet)`을 거쳐  
`Layer 4 계층(Handler, Service, Repository, Domain)`으로 전달되어 각 요청에 따른 서비스를 수행한다. 만약 클라이언트의  
모든 Request(요청)마다 컴포넌트들의 인스턴스가 새로 생성된다면 어떻게 될까? 클라이언트의 요청 수에 따라 인스턴스는 기하급수적으로  
증가할 것이며, 이는 시스템의 부하와 함께 결국 메모리 누수로 인한 비정상적인 종료로 이어질 것이다. 따라서 이러한 성격을 지닌 컴포넌트들은  
싱글톤을 적용해 `컨테이너`에서 따로 관리하고 있으며, 내부 필드는 별도의 상태를 가지지 않고 오직 메소드를 통해 지역 변수로만 특정 상태를  
송수신한다. 이처럼 **싱글톤 패턴은 무상태 객체 또는 설계상 유일해야 하는 시스템 컴포넌트에 적용**하는 것이 매우 바람직하다.

<br>

## 5. Java의 싱글톤 
다음은 Java에서 싱글톤을 구현하는 방법들을 설명하고 있다.

  * ### Static Block  ###
    <img width="545" alt="staticblock" src="https://user-images.githubusercontent.com/78818063/169226076-52521e5b-ea15-4d7a-8e4c-f7f3642fcd9e.png">

    `static 블록`을 사용하여 클래스 로더가 오브젝트를 수집할 때 한 번만 실행되는 특성을 이용해 초기화한다.  
    **인스턴스가 사용되는 시점이 아닌 클래스 로딩 시점에 할당**되는 단점이 있다.  
    
  * ### Lazy Init  ###
    <img width="543" alt="lazyinit" src="https://user-images.githubusercontent.com/78818063/169226081-cc511ea1-2f45-421b-8d9a-fdef4ec392ae.png">
    
    static 블록 초기화 방법을 개선하여 **인스턴스가 필요하여 요청한 시점에 할당하는 형태의 방법**이다.   
    하지만 getInstance() 메소드를 서로 다른 스레드가 동시에 호출하는 `동시성 문제`를 해결하지 못하였다.

  * ### Thread Safe + Lazy  ###
    <img width="545" alt="threadsafeLazy" src="https://user-images.githubusercontent.com/78818063/169226085-8d4762e3-d987-41f4-91fe-092579fe1bc7.png">
    
    Lazy Init에서 Thread Safe를 적용해 Side-Effect 문제를 개선한 방법이다. getInstance() 메소드에  
    **Synchronized 키워드를 함께 정의해 멀티 스레드 환경에서 발생할 동시성 문제를 해결**하고 있다.  
    하지만 해당 키워드를 사용해 애플리케이션의 성능 저하가 될 우려 소지가 있다.

  * ### Holder  ###
    <img width="545" alt="holder" src="https://user-images.githubusercontent.com/78818063/169226107-15939cc0-17ea-4159-ac5f-611461d3e231.png">
    
    마지막으로 **클래스 로더 매커니즘과 클래스 로드 시점을 이용해 내부 클래스를 통해 인스턴스를 할당하여 멀티스레드에서  
    발생할 동기화 문제를 예방**한다. 현재 싱글톤을 만들기 위해 사용되는 대표적인 방법이다.   

<br>

## 6. Spring Framework의 싱글톤
앞서 살펴본 싱글톤을 사용할 때 생기는 몇 가지 문제점들을 보았고, 실제 서버 환경에서 싱글톤을 활용하기엔 아직 완벽하게 납득이 되지 않는다.  
이에 Java 언어를 지원하는 `Spring Framework`에서는 직접 오브젝트들을 관리하는 `IoC(Inversion of Control) Container`를  
제공하고 있으며, 해당 컨테이너에서 관리되는 인스턴스를 `빈(Bean)`이라 표현한다. 스프링에서 빈을 등록할 때 **별다른 설정을 하지 안으면  
해당 빈의 기본 스코프는 싱글톤 상태**를 가지는데, 앞서 다뤘던 예제와 같이 클라이언트의 요청에 따라 매번 로직을 담당하는 인스턴스를 만드는 것은  
매우 비효율적이기 때문이다. 즉 요청에 따라 메시지를 담당하는 **스레드들이 생성되면 모두 싱글톤 타입의 빈을 공유해 사용**한다. 또한 5번 항목의  
전통적인 Java의 싱글톤 생성 방식을 따르면 실제 서비스에서 여러 단점과 문제점들이 생기므로, 스프링은 `Singleton Registry`를 통해 싱글톤으로    
객체를 만들고 관리한다. static과 private 키워드를 사용하지 않고 **평범한 public 접근 제어자만을 가진 클래스를 싱글톤으로 활용할 수 있도록  
만들어준다**. 따라서 의미 그대로 제어의 역전, 스프링에게 **인스턴스 생성 권한을 넘겨주어 해당 컨테이너에 넘긴 인스턴스의 필요한 상태를 개발자가  
아닌 스프링에서 모두 관리 및 제작**하여 편리하게 사용할 수 있다. Spring Framework의 자세한 내용은 다른 문서에서 자세히 다루도록 하자.   

<br>
